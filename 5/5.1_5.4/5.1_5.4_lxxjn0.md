# 인덱스 (5.1 ~ 5.4)

## 5.1 디스크 읽기 방식

데이터베이스의 성능 튜닝은 디스크 I/O를 줄이는 것과 많은 관련이 있다.

### 5.1.1 저장 매체

일반적으로 서버에서 사용되는 저장 매체는 아래와 같다.

- DAS(*Direct Attached Storage*)

- NAS(*Network Attached Storage*)

- SAN(*Storage Area Network*)

DAS는 독자적으로 사용이 불가능하고 컴퓨터 본체에 연결을 해야만 사용할 수 있다. 성능은 일반적인 PC의 내장 디스크와 비슷하고 여러 컴퓨터가 동시에 공유하는 것은 불가능하다. 이런 문제점을 해결하기 위해 주로 NAS 또는 SAN를 사용한다.

DAS는 SATA와 같은 케이블로 여러 컴퓨터와 동시에 연결 가능하고 NAS는 TCP/IP 방식으로 연결된다. NAS는 네트워크로 연결되는 만큼 SAN보다는 조금 속도가 느리다. SAN는 DAS로는 구축할 수 없는 대용량 스토리지 공간을 제공하는 장치이다. 다만 설비에 큰 비용이 드는 단점이 있다. NAS는 앞서 말한 것처럼 속도가 느리다. 그래서 데이터베이스 서버와 같이 읽기, 쓰기 작업이 잦은 용도로는 거의 사용되지 않는다. 위 저장 매체들은 대부분 디스크 드라이브의 플래터를 회전시켜 데이터를 읽고 쓰는 기계적인 방식을 사용한다.

### 5.1.2 디스크 드라이브와 솔리드 스테이트 드라이브

디스크 드라이브의 느린 속도를 보완하기 위해 등장한 것이 SSD(*Solid State Drive*)이다. 컴퓨터의 메모리(*D-ram*)보다는 느리지만 기계식 디스크 드라이브보다는 훨씬 빠르다.

순차 I/O에서는 SSD가 디스크 드라이브보다 조금 빠르거나 거의 비슷한 속도이다. 그러나 랜덤 I/O가 디스크 드라이브에 비해 훨씬 빠르다는 장점이 있다. 데이터베이스 서버에서는 순차 I/O 작업은 그다지 비중이 크지 않고 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 SSD 장점은 DBMS용 스토리지에 최적이라고 볼 수 있다.

### 5.1.3 랜덤 I/O와 순차 I/O

랜덤 I/O는 디스크 드라이브의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 만약 순차 I/O로 3개의 페이지를 읽는 데는 1번의 시스템 콜을 요청하지만, 랜덤 I/O로 3개의 페이지를 읽는 데는 3번의 시스템 콜을 요청한다.

디스크에서 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 이런 관점에서 순차 I/O는 랜덤 I/O보다 3배는 더 빠르다고 볼 수 있다. 

데이터베이스의 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 등의 기능이 내장된 것이다.

> [관련 질문 : [Issue #27] 바이너리 로그 버퍼와 InnoDB 로그 버퍼가 입출력 작업에 끼치는 영향](https://github.com/gazi-gazi/real-mysql/issues/27) 

쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 많지 않다. 그래서 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.

인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하고, 풀 테이블 스캔은 순차 I/O를 사용하낟. 그래서 상황에 따라 풀 테이블 스캔을 사용하도록 유도하는 경우도 발생한다.

## 5.2 인덱스란?

DBMS의 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(*key-value pair*)으로 인덱스를 만들어 둔다. 인덱스는 또한 이러한 검색을 빠르게 하기 위해 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

DBMS 인덱스의 자료구조로는 SortedList를 사용한다. 데이터 파일을 보관하는 자료구조는 ArrayList를 사용한다. 인덱스의 경우 항상 정렬된 상태를 유지해야 하기 때문에 SortedList를, 데이터 파일의 경우 별도의 정렬 없이 그대로 저장해도 되므로 ArrayList를 사용한다.

이때 두 자료구조의 장단점을 한 번 살펴보면 SortedList는 데이터의 변경이 생길 때 마다 데이터 정렬이 필요하다. 하지만 정렬된 데이터에서 값을 찾는 것은 매우 빠르게 가능하다. ArrayList의 경우 데이터의 변경이 생겨도 순서가 보장될 필요가 없으니 속도에 영향을 미치지 않는다. 그러나 정렬되지 않은 데이터에서 검색을 하는 경우는 많은 시간이 소요된다.

결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 대신 데이터의 읽기 속도를 높이는 기능이다. 인덱스의 추가 여부는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지의 여부로 결정돼야 한다.

인덱스의 역할별로 구분해 본다면 프라이머리 키(*Primary Key*)와 보조 키(*Secondary Key*)로 구분해 볼 수 있다.

- 프라이머리 키(*Primary Key*) : 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미한다. 이 칼럼은 통해 레코드를 식별 가능하므로 식별자라고 부르기도 한다. 프라이머리 키는 NULL과 중복을 허용하지 않는다.

- 프라이머리 키를 제외한 나머지 모든 인덱스는 보조 인덱스(*Secondary Index*)로 분류된다.

인덱스의 데이터 저장 방식(알고리즘)별로 구분하는 것은 많은 분류가 가능하겠지만 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다. 최근 새롭게 Fractal-Tree 인덱스와 같은 알고리즘도 도입됐다.

- B-Tree 알고리즘 : 가장 일반적으로 사용하는 알고리즘이다. 성숙된 상태이고 칼럼 값을 변형하지 않고 원래의 값을 이용해 인덱싱한다.
- Hash 알고리즘 : 해시 값을 계산해서 인덱싱하는 알고리즘이다. 빠른 검색이 가능하지만 값을 변형해서 인덱싱하므로 전방(Prefix) 일치와 같은 값 일부 검색을 사용할 수는 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.
- Fractal-Tree 알고리즘 : B-Tree 알고리즘의 단점을 보완하기 위해 나온 알고리즘이다. 값을 변형하지 않고 인덱싱는 것은 B-Tree와 비슷하지만 데이터가 저장되거나 삭제될 때 처리 비용을 줄일 수 있게 설계된 것이 특징이다. 아직은 성숙도는 떨어지지만 B-Tree 알고리즘을 대체할 수 있을 만한 알고리즘이다.

인덱스의 데이터 중복 허용 여부로 분류하면 유니크 인덱스(*Unique*)와 유니크 하지 않은 인덱스(*Non-unique*) 인덱스로 구분할 수 있다. 유니크한지 여부는 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제이다. 유니크 인덱스일 경우 동등 조건에 대한 검사는 항상 1건의 레코드만 검색하면 더 이상 찾지 않아도 된다는 내용을 옵티마이저에게 알려주는 효과를 낸다.

인덱스의 기능별로 분류해보면 전문 검색용 인덱스나 공간 검색용 인덱스 등이 있다.

## 5.3 B-Tree 인덱스

B-Tree 인덱스는 가장 범용적인 목적으로 사용되는 인덱스 알고리즘이다. 변형된 알고리즘으로는 여러 종류가 있는데, 일반적으로 DBMS에서는 주로 B+ Tree 또는 B* Tree가 사용된다. B-Tree에서 B는 Balanced를 의미한다.

B-Tree는 칼럼의 원래 값을 변형시키지 않고 항상 정렬된 상태로 유지하고 있다. 전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 사용할 정도로 일반적인 용도에 적합한 알고리즘이다.

> [관련 질문 : [Issue #26] 전문 검색에 사용되는 인덱스](https://github.com/gazi-gazi/real-mysql/issues/26)

### 5.3.1 구조 및 특성

B-Tree의 기본적인 구조로는 트리 구조의 최상위에 하나의 "루트 노드"가, 그 하위에는 자식 노드가 붙어있다. 가장 하위에 있는 노드를 "리프 노드"라 하고 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 "브랜치 노드"라고 한다. 인덱스의 리프 노드에는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다.

![img](http://d.jcole.us/blog/files/innodb/20130109/72dpi/B_Tree_Structure.png)

데이터 파일은 INSERT된 순서대로 저장되지 않는다. 만약 데이터가 삭제되면 그 빈 공간을 다른 데이터가 재사용할 수 있도록 DBMS가 설계되어 있기 때문이다.

> InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서대로 정렬되어 저장된다.

앞서 말한 것처럼 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가지게 된다. 그러나 이 레코드 주소는 DBMS 종류나 MySQL의 스토리지 엔진에 따라 의미가 달라진다. 오라클은 물리적인 레코드 주소가 되지만 MyISAM 테이블에서는 내부적인 레코드의 아이디를 의미한다. InnoDB 테이블에서는 프라이머리 키가 클러스터링되기 때문에 프라이므러 키값 자체가 주소 역할을 한다.

### 5.3.2 B-Tree 인덱스 키 추가 및 삭제

#### 인덱스 키 추가

새로운 키값이 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다. 저장될 키값으로 저장되어야 할 위치를 검색해야 한다. 만약 리프 노드가 꽉 차서 저장할 공간이 없을 경우 리프 노드를 분리하는데 이 과정이 브랜치 노드까지 영향을 미친다. 이런 탓에 쓰기 작업에 비용이 많이 드는 것으로 알려졌다.

인덱스 추가에 대한 비용을 간단하게 비교해보면 테이블에 레코드를 추가하는 작업 비용이 1이라면 테이블의 인덱스에 키를 추가하는 작업은 1~1.5 정도 예측한다. 이는 메모리와 CPU에서 처리하는 것이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기 때문에 시간이 오래 걸린다.

