# 7.4 SELECT

<br/>

## 7.4.1. SELECT 절 처리 순서

1. FROM
2. JOIN
3. WHERE
4. GROUP BY
5. HAVING
6. WINDOW functions
7. SELECT
8. DISTINCT
9. UNION
10. ORDER BY
11. LIMIT and OFFSET

**단, GROUP BY 가 없다면 예외적으로 ORDER BY가 드라이빙 테이블에 먼저 적용되는 경우가 있다.**

-  테스트를 해보았으나 GROUP BY가 없는 쿼리문에서 ORDER BY가 드라이빙 테이블에 먼저 적용되는 경우를 찾지 못했다.

<br/>

## 7.4.2. WHERE, GROUP BY, ORDER BY 의 인덱스 사용

WHERE, GROUP BY, ORDER BY 에서 인덱스를 사용하려면 가공하지 않은채로 사용해야 한다. 가공한다면 인덱스 레인지 스캔이 불가능하고 풀 스캔을 하게 된다.

- 인덱스를 사용 할 수 있는 경우

![image](https://user-images.githubusercontent.com/13347548/103667749-acb4b480-4fb9-11eb-9c50-adcb85534949.png)

- 인덱스를 사용하지 못하는 경우

![image](https://user-images.githubusercontent.com/13347548/103667857-c9e98300-4fb9-11eb-8d13-dd68c4b52bf3.png)

**결론, 인덱스 컬럼을 변형해서 사용하는 경우 인덱스를 이용할 수 없다.**

<br/>

### WHERE 절의 인덱스 사용

WHERE 절에서 사용하는 인덱스의 종류

1. 범위 제한 조건 
2. 체크 조건

#### 범위 제한 조건

`=`과 같은 동등 비교 조건, IN 절로 구성된 조건과 같이 얼마나 좌측부터 일치하는가에 따라 다르다.

#### 체크 조건

`>` 과 같은 부등호로 이루어진 조건으로 일치 여부가 아닌 비교로써 사용된다.

<br/>

WHERE 절에서 조건으로 사용되는 컬럼이 복수개일때 해당 컬럼들이 모두 인덱스를 사용하지 않고 OR 조건으로 엮여있다면 인덱스를 사용하지 못하고 풀 테이블 스캔을 한다. 이 경우 인덱스 스캔 + 풀 테이블 스캔이 단독으로 풀 테이블 스캔을 하는 경우보다 비용이 더 크기 때문이다.

다음 예제에서 employees의 인덱스는 first_name 과 hire_date 이다.

- 조건의 컬럼 중 한 개의 컬럼(first_name)만 인덱스에 해당하는 컬럼이고 이를 AND로 엮은 경우 인덱스를 사용한다.

![image](https://user-images.githubusercontent.com/13347548/103669389-a0c9f200-4fbb-11eb-9668-642478744793.png)

- 조건의 컬럼 중 한 개의 컬럼(first_name)만 인덱스에 해당하는 컬럼이고 이를 OR로 엮은 경우 인덱스를 사용하지 못 한다.

![image](https://user-images.githubusercontent.com/13347548/103669611-e7b7e780-4fbb-11eb-9306-1d8b1f3b09b4.png)

<br/>

궁금한점이 생겨서 실험을 해봤다. 그렇다면 OR 절에 사용되는 컬럼이 모두 인덱스에 해당한다면 반드시 인덱스를 사용할까?

- 조건의 컬럼이 모두 인덱스에 해당하고 OR 로 엮여있다. 그리고 모두 범위 제한 조건인 `=`을 사용한 경우 index_merge 방식이 선택되었다.

![image](https://user-images.githubusercontent.com/13347548/103670284-ba1f6e00-4fbc-11eb-9382-6ca2415b64da.png)

- 조건의 컬럼이 모두 인덱스에 해당하고 OR 로 엮여있다. 그리고 하나의 인덱스는 체크 조건인 `>`을 사용한 경우 row수에 따라 다른 방식이 선택되었다.

![image](https://user-images.githubusercontent.com/13347548/103670531-066aae00-4fbd-11eb-90ce-dffcd88fc411.png)

<br/>

![image](https://user-images.githubusercontent.com/13347548/103670636-29955d80-4fbd-11eb-97bf-4dc9f5976e0a.png)

**체크 조건을 사용하는 경우 인덱스를 사용하지 않는 경우가 발생할 수 있음을 주의하도록 하자.**

<br/>

### GROUP BY 절의 인덱스 사용

GROUP BY 절에 명시된 컬럼의 순서가 인덱스의 구성 순서와 같다면 사용할 수 있다.

인덱스 구성순서와 완벽히 일치해야하며 인덱스 구성요소 중 중간을 건너뛰고 사용해서도 안된다. 그리고 인덱스가 아닌 다른 요소가 절에 같이 포함되어 있어도 안된다.

> 그런데 5.6 기준 되는 것 같다.  
> 다중 컬럼 인덱스를 만들어서 실험해 봤는데 옵티마이저가 알아서 순서를 잡아주는 것 같다.

**그러나** 예외적인 상황이 있는데 WHERE 절에 인덱스 구성요소가 있는 경우이다.

WHERE 절에서 사용된 인덱스 컬럼을 GROUP BY 절로 내렸다고 가정할 때 인덱스 구성요소의 순서가 일치한다면 인덱스를 사용할 수 있다.

<br/>

### ORDER BY 절의 인덱스 사용

ORDER BY의 경우 GROUP BY의 조건에서 정렬의 조건이 하나 더 추가된다. 

**정렬 컬럼들의 정렬 순서가 전부 동일해야한다.**

<br/>

### WHERE 조건과 ORDER BY(GROUP BY) 절의 인덱스 사용

두 조건 절에 서로다른 인덱스를 사용할 수 있다면 이상적이겠지만 그렇게 하는 것은 불가능하다.

따라서 다음 세 가지 방법중 한가지 방법을 택해야한다.

1. WHERE, ORDER BY 에 같은 인덱스를 사용
   - 가장 빠른 방법이다
   - 가능하다면 이 방법을 사용하도록 튜닝하자
2. WHERE 에만 인덱스를 사용
   - WHERE 절에 일치하는 레코드의 수가 많을때 사용하자
3. ORDER BY 에만 인덱스를 사용
   - 많은 수의 레코드를 정렬해서 조회할 때 사용하자

<br/>

### GROUP BY 절과 ORDER BY 절의 인덱스 사용

GROUP BY 와 ORDER BY 가 같이 사용된 쿼리에서 둘중 하나라도 인덱스를 사용하지 못하면 모두 인덱스를 사용하지 못한다.

<br/>

### WHERE 조건과 ORDER BY 절, 그리고 GROUP BY 절의 인덱스 사용

위 3개의 조건이 모두 사용된 쿼리에서 인덱스가 사용되는 경우는 세 가지이다.

1. WHERE, GROUP BY, ORDER BY 가 인덱스 사용조건을 만족
2. WEHRE 절만 인덱스 사용조건을 만족
3. GROUP BY, ORDER BY 절만 인덱스 사용조건을 만족

<br/>

## 7.4.3. WHERE 절의 비교 조건 사용 시 주의사항

<br/>

### NULL 비교

MYSQL 은 NULL 또한 인덱스에서 하나의 값으로 사용할 수 있다. 비교를 할 때는 IS NULL 을 사용하도록 하자.

ISNULL() 함수를 사용하는 것 보다 IS NULL 연산자를 사용하는 것이 더 효율적이다.

### 문자열이나 숫자 비교

타입을 맞춰서 비교를 하도록 하자.

숫자 컬럼에 문자열 컬럼을 사용한다음 숫자로 변환해서 인덱스를 태울 수 있지만 반대의 경우에는 그렇지 못하다.

### 날짜 비교

#### DATE나 DATETIME과 문자열 비교

DATE와 DATETIME을 비교하면 DATETIME에 맞춰 비교를 하고 성능 저하는 일어나지 않는다. 그러나 해당 컬럼의 값들을 문자열로 수정해서 비교를 하는 경우 인덱스를 효율적으로 이용하지 못한다.

언제나 그렇듯 상수를 변형하도록 하자.

<br/>

## 7.4.4. DISTINCT

집합 함수(ex. MIN, MAX, COUNT)와 같이 DISTINCT를 사용할 때 인덱스를 사용하지 못하면 임시 테이블이 필요한데 실행계획의 extra에 "Using Temporary" 가 출력되지 않는다.

잘못 사용하는 경우가 있는데

`SELECT DISTINCT first_name, last_name FROM employees;` 와 같은 쿼리는 first_name + last_name 을 합친 레코드의 유니크함을 조회하는 것이다.

`SELECT DISTINCT (first_name), last_name FROM employees;` 처럼 괄호를 추가한다고 달라지지 않는다. 

### 집합 함수와 함께 사용된 DISTINCT

그러나 집합 함수 내에서 사용된 DISTINCT는 집합 함수의 인자로 전달된 컬럼의 유니크한 값들만 조회한다. 그리고 이 경우 인덱스 대신 임시테이블을 사용하지만 Using temporary가 나타나지 않는다.

이렇게 생성된 임시 테이블에는 유니크 인덱스가 자동 생성되면서 레코드가 많으면 느려질 수 있다.

그러나 인덱스 컬럼에 대해 적용한다면 임시 테이블이 아닌 인덱스를 효율적으로 사용하여 처리한다.

</br>

## 7.4.5. LIMIT n

기본적으로 LIMIT 에서 필요한 레코드가 준비되면 스토리지 엔진으로부터 읽기 작업을 멈춘다.

다만 인덱스를 사용하지 못하는 GROUP BY의 경우 그룹핑과 정렬의 작업이 필요하기 때문에 성능 향상에 큰 영향을 미치지 못한다.

ORDER BY의 경우 정렬을 LIMIT에서 필요한 갯수만큼만 정렬을 하고 쿼리를 멈춘다.

<br/>

## 7.4.6. JOIN

다시한번 살펴보는 인덱스 스캔으로 레코드를 읽는 작업

1. 인덱스 탐색(index seek) : 인덱스 조건에 맞는 값의 위치를 찾는다.
2. 인덱스 스캔(index scan) : 찾은 위치부터 필요한 만큼 인덱스를 읽는다.
3. 인덱스를 읽은 만큼 레코드를 읽어온다.

:arrow_right: 인덱스 풀 스캔은 1의 과정은 필요없지만 2의 과정에서 전부 읽어서 3에 대한 비용이 크다.

:arrow_right: 인덱스 레인지 스캔은 1의 과정에 비용이 크지만 2의 대한 비용이 적다.

---

- 드라이빙 테이블 : 인덱스 탐색과정은 한 번 수행, 그 이후 스캔 실행
- 드리븐 테이블 : 인덱스 탐색, 스캔 과정을 **드라이빙 테이블에서 읽은 레코드 건수 만큼 반복**

따라서 조인에 대한 부하는 드리븐 테이블이 더 큰 비용을 차지하기 때문에 **옵티마이저는 드리븐 테이블을 잘 읽을수 있게 최적화** 한다.

1. 테이블 둘다 인덱스가 있거나 둘다 인덱스가 없는 경우
   - 옵티마이저가 알아서 해준다.
2. 한 테이블만 인덱스가 있는 경우
   - 인덱스를 가지고 있는 테이블을 드리븐 테이블로 지정한다.

<br/>

### JOIN 컬럼의 데이터 타입

데이터 타입은 항상 일치시켜주도록 하자. 괜히 풀스캔 일어나고 인덱스는 제대로 사용하지 못하는 경우가 발생할 수 있다.

특히 다음과 같은 경우 주의하자.

- 완전 서로 다른 데이터 타입을 비교
- 같은 CHAR 타입이지만 문자 집합, 콜레이션이 다른경우 (ex. latin-utf )
- 같은 INT 인데 부호(sign)의 여부

그런데 어지간히 주의 안하지 않으면 위와 같은 상황이 발생할리는 없을 것 같다.

<br/>

### OUTER JOIN 의 주의사항

**OUTER JOIN 의 조인 컬럼의 조건을 ON 절에 명시하지 않고 WHERE 절에 명시하면 옵티마이저가 INNER JOIN 과 같은 방식으로 처리해버린다.**

<br/>

### OUTER JOIN 과 COUNT(*)

COUNT 를 수행함에 있어 불필요한 조인이 있는지 유의해야하는데 다음 두개의 조건을 만족하면 조인 절을 제거하도록 하자.

1. 조인해서 레코드가 늘어나지 않음 :arrow_right: 1 : 1, N : 1
2. 조인해서 레코드가 줄어들지 않음 :arrow_right: 드리븐 OUTER​ 테이블에 조인 조건외에 아무런 조건이 없는 경우

위 두개를 만족하면 레코드 결과에 아무런 영향을 미치지 않는다.

<br/>

### OUTER JOIN 을 이용한 ANTI JOIN

한쪽 테이블에만 존재하는 값을 찾을 때 사용하는 기법이다.

OUTER JOIN 을 한 다음, 값이 존재하는지 WHERE 절에 IS NULL 을 이용해서 판별해내면 된다.

<br/>

### INNER JOIN 과 OUTER JOIN 선택

한줄 요약.

둘이 성능 차이 없으니까 상황에 맞게 적절히 선택하자.

<br/>

### FULL OUTER JOIN 구현

두 개의 쿼리를 UNION 으로 같은 효과를 낼 수 있다.

버퍼에 의한 성능저하가 걱정된다면 뮤텍스 테이블을 이용해서 우회하도록 하자.

<br/>

### 조인 순서로 인한 쿼리 실패

조인 순서를 마음대로 마구 적어서는 안된다.

**조인은 반드시 JOIN 좌-우측에 명시된 테이블만 적용**해야한다.

<br/>

### JOIN 과 FOREIGN KEY

아무런 관계가 없다. 

외래키는 애시당초 참조 무결성을 지키기 위한 제약조건일 뿐이다. 외래키가 없다고 조인을 못할 이유는 전혀 없다.

<br/>

### 지연된 조인(Delayed Join)

지연된 조인이란 조인이 실행되기 전에 GROUP BY, ORDER BY 를 먼저 처리하는 방식을 의미한다. LIMIT 절을 같이 사용하면 더 큰 성능적 이점을 얻을 수 있다.

사용하는 방법을 통짜로 된 하나의 쿼리를 서브쿼리로 쪼개서 서브쿼리에서 GROUP BY, ORDER BY, LIMIT 절을 실행해 주는 것이다. 그러면 결과 수가 LIMIT 이하로 줄어들기 때문에 파생 테이블을 이용한다 하더라도 큰 성능상 이점을 얻어갈 수 있다.

이러한 지연된 조인은 페이징 쿼리를 처리할 때 큰 성능 향상을 낼 수 있다.

 LIMIT 10 일 경우에는 지연된 조인을 사용하지 않아도 성능상 문제가 되지 않지만 OFFSET에 해당하는 조건이 생성되면 불필요하게 읽게되는 레코드와 불필요한 조인이 마구 발생하게 된다. 따라서 LIMIT 절을 이용하는 부분을 서브쿼리로 넘겨서 처리하도록 변경하면 성능이 좋아지게 튜닝할 수 있다.

그런데 조건이 있다.

1. LEFT JOIN 의 경우 1:1, 1:N 관계일 것 :arrow_right: 레코드의 결과가 늘어나지 말아야 한다.
2. INNER JOIN 의 경우 레코드의 결과가 늘어나지도 줄어들지도 말아야 한다. 

> 이런 방법도 있지만 no offset 이라는 기법을 이용해서 해결할 수 있다.
>
> [킹졸두](https://jojoldu.tistory.com/528) 님이 해당 방법에 대한 포스팅을 해두셨으니 꼭 보도록 합시다!

<br/>

### 조인 버퍼 사용으로 인한 정렬 흐트러짐

네스티드 루프 방식의 조인으로 인해 보통의 경우 드라이빙 테이블을 기준으로 정렬이 된다.

**하지만**

조인 버퍼를 사용하는 경우 기존 드라이빙 테이블이 드리븐으로, 드리븐 테이블이 드라이빙으로 역전이 된다.  
그래서 '아, 드리븐 테이블 기준으로 정렬되겠다! ㅎㅎ' 할 수 있는데 그냥 맘대로 뒤섞여 버리니까 주의하도록 하자.

> 조인 버퍼를 사용한다는 건 드리븐 테이블이 인덱스를 못써서 드라이빙 테이블의 결과를 메모리에 적재하는 것일텐데  
> 이 때 메모리에 적재할 때 굳이 정렬을 안해도 O(1)의 시간복잡도를 보장하니까 아마 순서가 뒤죽박죽이 되는게 아닐까 싶다.

