# 7.4 SELECT

<br/>

## 7.4.1. SELECT 절 처리 순서

1. FROM
2. JOIN
3. WHERE
4. GROUP BY
5. HAVING
6. WINDOW functions
7. SELECT
8. DISTINCT
9. UNION
10. ORDER BY
11. LIMIT and OFFSET

**단, GROUP BY 가 없다면 예외적으로 ORDER BY가 드라이빙 테이블에 먼저 적용되는 경우가 있다.**

-  테스트를 해보았으나 GROUP BY가 없는 쿼리문에서 ORDER BY가 드라이빙 테이블에 먼저 적용되는 경우를 찾지 못했다.

<br/>

## 7.4.2. WHERE, GROUP BY, ORDER BY 의 인덱스 사용

WHERE, GROUP BY, ORDER BY 에서 인덱스를 사용하려면 가공하지 않은채로 사용해야 한다. 가공한다면 인덱스 레인지 스캔이 불가능하고 풀 스캔을 하게 된다.

- 인덱스를 사용 할 수 있는 경우

![image](https://user-images.githubusercontent.com/13347548/103667749-acb4b480-4fb9-11eb-9c50-adcb85534949.png)

- 인덱스를 사용하지 못하는 경우

![image](https://user-images.githubusercontent.com/13347548/103667857-c9e98300-4fb9-11eb-8d13-dd68c4b52bf3.png)

**결론, 인덱스 컬럼을 변형해서 사용하는 경우 인덱스를 이용할 수 없다.**

<br/>

### WHERE 절의 인덱스 사용

WHERE 절에서 사용하는 인덱스의 종류

1. 범위 제한 조건 
2. 체크 조건

#### 범위 제한 조건

`=`과 같은 동등 비교 조건, IN 절로 구성된 조건과 같이 얼마나 좌측부터 일치하는가에 따라 다르다.

#### 체크 조건

`>` 과 같은 부등호로 이루어진 조건으로 일치 여부가 아닌 비교로써 사용된다.

<br/>

WHERE 절에서 조건으로 사용되는 컬럼이 복수개일때 해당 컬럼들이 모두 인덱스를 사용하지 않고 OR 조건으로 엮여있다면 인덱스를 사용하지 못하고 풀 테이블 스캔을 한다. 이 경우 인덱스 스캔 + 풀 테이블 스캔이 단독으로 풀 테이블 스캔을 하는 경우보다 비용이 더 크기 때문이다.

다음 예제에서 employees의 인덱스는 first_name 과 hire_date 이다.

- 조건의 컬럼 중 한 개의 컬럼(first_name)만 인덱스에 해당하는 컬럼이고 이를 AND로 엮은 경우 인덱스를 사용한다.

![image](https://user-images.githubusercontent.com/13347548/103669389-a0c9f200-4fbb-11eb-9668-642478744793.png)

- 조건의 컬럼 중 한 개의 컬럼(first_name)만 인덱스에 해당하는 컬럼이고 이를 OR로 엮은 경우 인덱스를 사용하지 못 한다.

![image](https://user-images.githubusercontent.com/13347548/103669611-e7b7e780-4fbb-11eb-9306-1d8b1f3b09b4.png)

<br/>

궁금한점이 생겨서 실험을 해봤다. 그렇다면 OR 절에 사용되는 컬럼이 모두 인덱스에 해당한다면 반드시 인덱스를 사용할까?

- 조건의 컬럼이 모두 인덱스에 해당하고 OR 로 엮여있다. 그리고 모두 범위 제한 조건인 `=`을 사용한 경우 index_merge 방식이 선택되었다.

![image](https://user-images.githubusercontent.com/13347548/103670284-ba1f6e00-4fbc-11eb-9382-6ca2415b64da.png)

- 조건의 컬럼이 모두 인덱스에 해당하고 OR 로 엮여있다. 그리고 하나의 인덱스는 체크 조건인 `>`을 사용한 경우 row수에 따라 다른 방식이 선택되었다.

![image](https://user-images.githubusercontent.com/13347548/103670531-066aae00-4fbd-11eb-90ce-dffcd88fc411.png)

<br/>

![image](https://user-images.githubusercontent.com/13347548/103670636-29955d80-4fbd-11eb-97bf-4dc9f5976e0a.png)

**체크 조건을 사용하는 경우 인덱스를 사용하지 않는 경우가 발생할 수 있음을 주의하도록 하자.**

<br/>

### GROUP BY 절의 인덱스 사용

GROUP BY 절에 명시된 컬럼의 순서가 인덱스의 구성 순서와 같다면 사용할 수 있다.

인덱스 구성순서와 완벽히 일치해야하며 인덱스 구성요소 중 중간을 건너뛰고 사용해서도 안된다. 그리고 인덱스가 아닌 다른 요소가 절에 같이 포함되어 있어도 안된다.

> 그런데 5.6 기준 되는 것 같다.  
> 다중 컬럼 인덱스를 만들어서 실험해 봤는데 옵티마이저가 알아서 순서를 잡아주는 것 같다.

**그러나** 예외적인 상황이 있는데 WHERE 절에 인덱스 구성요소가 있는 경우이다.

WHERE 절에서 사용된 인덱스 컬럼을 GROUP BY 절로 내렸다고 가정할 때 인덱스 구성요소의 순서가 일치한다면 인덱스를 사용할 수 있다.

<br/>

### ORDER BY 절의 인덱스 사용

ORDER BY의 경우 GROUP BY의 조건에서 정렬의 조건이 하나 더 추가된다. 

**정렬 컬럼들의 정렬 순서가 전부 동일해야한다.**

<br/>

### WHERE 조건과 ORDER BY(GROUP BY) 절의 인덱스 사용

두 조건 절에 서로다른 인덱스를 사용할 수 있다면 이상적이겠지만 그렇게 하는 것은 불가능하다.

따라서 다음 세 가지 방법중 한가지 방법을 택해야한다.

1. WHERE, ORDER BY 에 같은 인덱스를 사용
   - 가장 빠른 방법이다
   - 가능하다면 이 방법을 사용하도록 튜닝하자
2. WHERE 에만 인덱스를 사용
   - WHERE 절에 일치하는 레코드의 수가 많을때 사용하자
3. ORDER BY 에만 인덱스를 사용
   - 많은 수의 레코드를 정렬해서 조회할 때 사용하자

<br/>

### GROUP BY 절과 ORDER BY 절의 인덱스 사용

GROUP BY 와 ORDER BY 가 같이 사용된 쿼리에서 둘중 하나라도 인덱스를 사용하지 못하면 모두 인덱스를 사용하지 못한다.

<br/>

### WHERE 조건과 ORDER BY 절, 그리고 GROUP BY 절의 인덱스 사용

위 3개의 조건이 모두 사용된 쿼리에서 인덱스가 사용되는 경우는 세 가지이다.

1. WHERE, GROUP BY, ORDER BY 가 인덱스 사용조건을 만족
2. WEHRE 절만 인덱스 사용조건을 만족
3. GROUP BY, ORDER BY 절만 인덱스 사용조건을 만족

<br/>

## 7.4.3. WHERE 절의 비교 조건 사용 시 주의사항

<br/>

### NULL 비교

MYSQL 은 NULL 또한 인덱스에서 하나의 값으로 사용할 수 있다. 비교를 할 때는 IS NULL 을 사용하도록 하자.

ISNULL() 함수를 사용하는 것 보다 IS NULL 연산자를 사용하는 것이 더 효율적이다.

### 문자열이나 숫자 비교

타입을 맞춰서 비교를 하도록 하자.

숫자 컬럼에 문자열 컬럼을 사용한다음 숫자로 변환해서 인덱스를 태울 수 있지만 반대의 경우에는 그렇지 못하다.

### 날짜 비교

#### DATE나 DATETIME과 문자열 비교

DATE와 DATETIME을 비교하면 DATETIME에 맞춰 비교를 하고 성능 저하는 일어나지 않는다. 그러나 해당 컬럼의 값들을 문자열로 수정해서 비교를 하는 경우 인덱스를 효율적으로 이용하지 못한다.

언제나 그렇듯 상수를 변형하도록 하자.

<br/>

## 7.4.4. DISTINCT

집합 함수(ex. MIN, MAX, COUNT)와 같이 DISTINCT를 사용할 때 인덱스를 사용하지 못하면 임시 테이블이 필요한데 실행계획의 extra에 "Using Temporary" 가 출력되지 않는다.

잘못 사용하는 경우가 있는데

`SELECT DISTINCT first_name, last_name FROM employees;` 와 같은 쿼리는 first_name + last_name 을 합친 레코드의 유니크함을 조회하는 것이다.

`SELECT DISTINCT (first_name), last_name FROM employees;` 처럼 괄호를 추가한다고 달라지지 않는다. 

### 집합 함수와 함께 사용된 DISTINCT

그러나 집합 함수 내에서 사용된 DISTINCT는 집합 함수의 인자로 전달된 컬럼의 유니크한 값들만 조회한다. 그리고 이 경우 인덱스 대신 임시테이블을 사용하지만 Using temporary가 나타나지 않는다.

이렇게 생성된 임시 테이블에는 유니크 인덱스가 자동 생성되면서 레코드가 많으면 느려질 수 있다.

그러나 인덱스 컬럼에 대해 적용한다면 임시 테이블이 아닌 인덱스를 효율적으로 사용하여 처리한다.

</br>

## 7.4.5. LIMIT n

기본적으로 LIMIT 에서 필요한 레코드가 준비되면 스토리지 엔진으로부터 읽기 작업을 멈춘다.

다만 인덱스를 사용하지 못하는 GROUP BY의 경우 그룹핑과 정렬의 작업이 필요하기 때문에 성능 향상에 큰 영향을 미치지 못한다.

ORDER BY의 경우 정렬을 LIMIT에서 필요한 갯수만큼만 정렬을 하고 쿼리를 멈춘다.

<br/>

