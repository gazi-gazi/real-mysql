## 6.3 MySQL의 주요 처리 방식

- '풀 테이블 스캔'만 스토리지 엔진에서 처리
- 나머지는 모두 MySQL 엔진에서 처리되는 내용
- MySQL 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 미치는 영향력이 큰데 모두 쿼리의 성능을 저하시키는데 한몫하는 작업
- MySQL 엔진이 처리하는데 시간이 오래 걸리는 작업의 원리를 알아둔다면 쿼리를 튜닝하는데 상당한 도움이 될 것이다.

### 6.3.1 풀 테이블 스캔

- 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 것을 의미

조건

- 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리임에도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)
- max_seeks_for_key 변수를 특정 값(N)으로 설정하면 인덱스의 Cardinality나 Selectivity를 무시하고 최대 N건만 읽으면 된다고 판단. 값을 작게 설정할수록 MySQL 서버가 인덱스를 더 사용하도록 유도함.

풀 테이블 스캔을 하는 방식

- MyISAM에서는 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어 온다

InnoDB의 read ahead

- 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 read ahead 작업이 자동으로 시작
- read ahead란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것을 의미
- 처음 데이터 페이지는 Foreground thread가 페이지 읽기를 실행하지만 특정 시점(innodb_read_ahead_threshold)부터는 읽기 작업을 백그라운드 스레드로 넘긴다
- 데이터 웨어 하우스용으로 MySQL을 사용한다면 이 값을 더 낮게 설정해서 더 자주 read ahead가 시작되도록 하는 것도 좋은 방법이다.

### 6.3.2 ORDER BY 처리(Using filesort)

index

장점: INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.

단점: INSERT, UPDATE, DELTE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 많이 필요하다. 인덱스가 개수가 늘어날수록 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시용 메모리가 많이 필요하다.

Filesort

장점: 인덱스를 생성하지 않으므로 인덱스를 이용할 때의 단점이 장점. 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.

단점: 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.

index 정렬이 힘든 이유

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT와 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

- 인덱스를 이용하지 않고 별도의 정렬처리를 수행했는지는 실행 계획의 Extra 칼럼에 "Using filesort"라는 코멘트가 있는지 보면 된다.

#### Sort buffer

- Sort buffer란 MySQL이 정렬을 수행하기 위해 사용하는 별도의 메모리 공간
- 정렬이 필요한 경우만 할당되며 버퍼의 크기는 가변적이지만 최대 사용 가능한 sort buffer의 공간은 sort_buffer_size라는 시스템 변수로 설정 가능

##### 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면?

- MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/475cfb64-30e1-42c8-af09-25867e3cbc5d/IMG_2236.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/475cfb64-30e1-42c8-af09-25867e3cbc5d/IMG_2236.jpg)

- 위 그림처럼 sort buffer에서 정렬을 수행하고 결과를 임시로 디스크에 기록해둔다.
- 이 과정을 반복하며 각 버퍼 크기 만큼씩 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다.
- 이 병합 작업을 멀티 머지(Multi-merge)라고 표현하며, 수행된 멀티 머지 횟수는 Sort_merge_passes라는 상태 변수에 누적된다.

##### 소트 버퍼를 무조건 크게 설정하면 좋은거 아니야?

- 실제 벤치마크 결과로는 거의 차이가 없었다
- sort buffer의 크기가 256KB에서 512KB 사이에서 최적의 성능을 보였다.
- 8MB 이상에서 성능이 조금더 향상되는 것으로 벤치마킹됐다는 자료도 있는데, 이는 웹과 같은 OLTP 성격의 쿼리보다 대용량 작업에 해당하는 내용일 것으로 보인다.
- 그래서 sort buffer의 크기는 56KB에서 1MB 미만이 적절한 것으로 생각

##### 높게 설정했을 때 문제점

- MySQL은 글로벌 메모리 영역과 세션(로컬) 메모리 영역으로 나눠서 생각할 수 있다.
- sort buffer는 세션 메모리 영역에 해당 즉, 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다.
- 커넥션이 많아지고, 정렬 작업이 많을수록 sort buffer로 소비되는 메모리 공간이 커진다.
- 이 때 메모리 부족 현상을 겪을 수 있고 OOM-Killer는 메모리를 가장 많이 사용하고 있는 프로세스를 강제 종료하는데 일반적으로 MySQL 서버가 1순위가 된다.

#### 정렬 알고리즘

- 두 가지 방법. 레코드 전체를 소트 버퍼에 담을지, 정렬 기준 칼럼만 버퍼에 담을지

##### 싱글 패스(Single pass) 알고리즘

- SELECT되는 칼럼 전부를 담아서 정렬을 수행하는 방법

```sql
SELECT emp_no, first_name, last_name
FROM employees
ORDER BY first_name;
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/00f70593-daa1-446f-b46a-7bf54b6748e9/IMG_A25D689AA9D8-1.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/00f70593-daa1-446f-b46a-7bf54b6748e9/IMG_A25D689AA9D8-1.jpeg)

- 정렬에 필요하지 않은 last_name 칼럼까지 전부 읽어서 소트 버퍼에 담고 정렬을 수행
- 정렬이 완료 되면 결과를 클라이언트에게 그대로 전달

##### 투 패스(Two pass) 알고리즘

- 정렬 대상 칼럼과 프라이머리 키 값만을 소트 버퍼에 담아서 정렬을 수행
- 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 알고리즘

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ead9dffc-d394-4797-86b1-d8984e9e7e03/IMG_5F61440B6712-1.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ead9dffc-d394-4797-86b1-d8984e9e7e03/IMG_5F61440B6712-1.jpeg)

- 정렬에 필요한 first_name 칼럼과 프라이머리 키인 emp_no만 읽어서 정렬을 수행한다.
- 이 정렬이 완료되면 테이블을 한 번 더 읽어서 필요한 칼럼을 가져오고 그 결과를 클라이언트한테 넘긴다.
- 테이블을 (그것도 같은 레코드를) 두 번 읽어야 하기 때문에 상당히 불합리하지만 싱글패스 알고리즘은 이런 불합리가 없다.
- 하지만 싱글 패스 알고리즘은 더 많은 소트 버퍼 공간이 필요하다.

##### 싱글 패스 알고리즘을 사용하지 않고 투 패스 알고리즘을 사용하는 경우 

- 레코드의 크기가 max_length_for_sort_data 파라미터로 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때

#### 정렬의 처리 방식

- ORDER BY가 사용되면 반드시 3가지 처리 방식 중 하나로 정렬이 처리

인덱스 사용한 정렬

- 옵티마이저가 인덱스를 사용해서 정렬 처리가 가능한지 검토하고, 가능하다면 인덱스를 순서대로 읽어서 결과를 반환
- 실행 계획의  Extra 코멘트에 별도의 내용 표기 없음

드라이빙 테이블만 정렬(조인이 없는 경우 포함) 

- 드라이빙 테이블만 정렬한 다음 조인 수행(조인이 없으면 넘어감)
- 실행 계획의 Extra 코멘트에 "Using filesort"가 표시됨

조인 결과를 임시 테이블로 저장한 후 임시 테이블에서 정렬

- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행
- 실행 계획의 Extra 코멘트에 "Using temporary; Using filesort"가 같이 표시됨

##### 인덱스를 이용한 정렬

- ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
- WHERE 절에 첫 번째 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.(그렇지 않을 경우 WHERE로 찾을 때 해당하는 인덱스로 검색하기 때문)
- B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다. R-Tree도 이 방식을 사용할 수 없다.
- 여러 테이블이 조인되는 경우에는 네스티드-루프(Nested-loop) 방식의 조인에서만 이 방식을 사용할 수 있다.

- 인덱스를 사용한 정렬이 가능한 이유는  B-Tree 인덱스가 키 값으로 정렬돼 있기 때문이다.
- 또한 조인이 네스티드-루프 방식으로 실행되기 때문에 조인 때문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다.
- 하지만 조인이 사용된 쿼리의 실행 계획에 조인 버퍼가 사용되면 순서가 흐트러질 수 있기 때문에 주의해야 한다.

##### 드라이빙 테이블만 정렬 

- 조인을 실행하기 전에, 드라이빙 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책
- 즉, 이는 조인에서 드라이빙 테이블의 칼럼만으로 ORDER BY 절이 작성돼야 한다.

##### 임시 테이블을 이용한 정렬

- 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다.
- 드라이빙 테이블만 정렬하는 상황 외에는 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.
- 정렬이 수행되기 전에 반드시 드리븐 테이블을 읽어햐 하면(정렬 기준이 드리븐 테이블의 칼럼이라면) 반드시 조인된 데이터를 가지고 정렬할 수 밖에 없다.
- Extra 칼럼에 "Using temporary; Using filesort"는 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리 했음을 의미한다.

##### 정렬 방식의 성능 비교

- 쿼리가 처리되는 2가지 방법: 스트리밍 처리와 버퍼링 처리

스트리밍(Streaming) 방식

- 처리할 데이터가 얼마나 될지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식. 가장 마지막 레코드는 언제 받을지 알 수 없지만, 그다지 중요하지 않다.
- LIMIT과 같이 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있다.
- 하지만 JDBC 라이브러는 자체적으로 버퍼링 방식을 사용한다. 이것은 JDBC의 기본 작동 방식이고, 대량의 데이터를 가져와야 할 때는 전송 방식을 스트리밍으로 변경할 수 있다.

버퍼링(Buffering) 방식

- ORDER BY나 GROUP BY와 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다.
- 결과를 모아서 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 때까지 기다려야 한다.
- 그래서 이런 방식은 LIMIT 같은 제한이 있어도 성능 향상에 별로 도움이 되지 않는다.

- ORDER BY의 3가지 처리 방식 가운데 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이고, 나머지는 모두 버퍼링 된 후에 정렬된다.
- 즉, 인덱스를 사용한 정렬 방식은 LIMIT로 제한된 건수만큼만 읽으면서 바로바로 클라이언트로 결과를 전송해줄 수 있다.
- 인덱스를 사용하지 못하는 경우는 모든 레코드를 읽어서 정렬한 후에야 비로소 LIMIT로 제한된 건수만큼 잘라서 클라이언트로 전송해줄 수 있음을 의미한다.

#### 정렬 관련 상태 변수

- MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장하고 있다.
- SHOW SESSION STATUS LIKE 'Sort%'; 로 확인해볼 수 있다.
- Sort_merge_passes는 멀티 머지 처리 횟수를 의미한다.
- Sort_range는 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수다.
- Sort_scan은 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수다.
- Sort_rows는 지금까지 정렬한 전체 레코드 건수를 의미한다.

### 6.3.3 GROUP BY 처리

- GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눠볼 수 있다.
- 인덱스를 사용할 때는 인덱스를 차례대로 이용하는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔이라는 방법으로 나뉜다.
- 인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용한다.

#### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

- ORDER BY와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그룹핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행
- 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 이용하므로 추가적인 정렬 작업은 필요하지 않다.
- 이런 그룹핑 방식의 실행 계획에서는 Extra 칼럼에 GROUP BY 관련 코멘트(Using index for group-by)나 임시 테이블이나 정렬 관련 코멘트(Using temporary, Using filsort)가 표시되지 않는다.

#### 루스(loose) 인덱스 스캔을 이용하는 GROUP BY

- 루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 가져오는 것을 의미
- MySQL의 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다.
- Prefix index(칼럽 값의 앞쪽 일부만 생성된 인덱스)는 루스 인덱스 스캔을 사용할 수 없다.
- 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다.
- 즉, 루스 인덱스 스캔은 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만들어낸다.

#### 임시 테이블을 사용하는 GROUP BY

- GROUP BY 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계 없이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다.
- 인덱스를 전혀 사용할 수 없는 GROUP BY에서는 임시 테이블을 사용하기 때문에 실행 계획의 Extra 칼럼에 "Using temporary; Using filesort"가 표시된다.
- 이 임시 테이블은 원본 쿼리에서 GROUP BY 절에 사용된 칼럼과 SELECT하는 칼럼만 저장한다.
- 이 때 GROUP BY 절에 사용된 칼럼으로 유니크 키를 생성한다. 즉, GROUP BY가 임시 테이블로 처리되는 경우 사용되는 임시 테이블은 항상 유니크 키를 가진다.
- 만약 ORDER BY 절에 명시된 칼럼과 GROUP BY 절에 명시된 칼럼이 같으면 별도의 정렬 작업을 수행하지 않는다. 다르다면 Filesort 과정을 거쳐 다시 한 번 정렬 작업을 수행한다.

### 6.3.4 DISTINCT 처리

- DISTINCT는 집합 함수와 함께 사용되는 경우와 집합 함수가 없는 경우 2가지가 있다.
- 집합함수의 유무에 의해서 DISTINCT 키워드가 영향을 미치는 범위가 달라지기 때문이다.
- 집함 함수 같이 DISTINCT가 사용되는 쿼리의 실행 계획에서 DISTINCT 처리가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요하다.
- 하지만 실행 계획의 Extra 칼럼에는 "Using temporary" 메시지가 출력되지 않는다.

#### SELECT DISTINCT

- SELECT 되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 SELECT DISTINCT 형태의 쿼리 문장을 사용
- 이 경우 GROUP BY와 거의 같은 방식으로 처리 되지만 SELECT DISTINCT의 경우에는 정렬이 보장되지 않는다.
- 아래 두 개의 쿼리는 모두 인덱스를 이용하기 때문에 부가적인 정렬 작업이 필요하지 않으며 완전히 같은 쿼리이다.

```sql
SELECT DISTINCT emp_no FROM salaries;
SELECT emp_no FROm salaries GROUP BY emp_no;
```

- DISTINCT는 SELECT하는 레코드(튜플)을 유니크하게 SELECT하는 것이지 칼럼을 유니크하게 조회하는 것이 아니다.

```sql
SELECT DISTINCT first_name, last_name FROm employees;
SELECT DISTINCT(first_name), last_name FROm employees;
```

- 위의 쿼리는 first_name만 유니크하게 조회한다고 생각할 수 있지만 (first_name + last_name)이 유니크한 것을 조회하는 쿼리이다.
- MySQL 서버는 DISTINCT 뒤의 괄호를 그냥 의미없이 사용된 괄호로 해석하고 제거해버린다.
- SELECT하는 여러 칼럼 중에서 일부 칼럼만 유니크하게 조회하는 방법은 없다.
- 단, DISTINCT가 집합 함수 내에 사용된 경우는 조금 다르다.

#### 집합 함수와 함께 사용된 DISTINCT

- 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼 값들 중에서 중복을 제거하고 남은 값만을 가져온다.

```sql
EXPLAIN
SELECT COUNT(DISTINCT s.salary)
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no
AND e.emp_no BETWEEN 100001 AND 100100;
```

- 위 쿼리는 내부적으로 "COUNT(DISTINCT s.salary)"를 처리하기 위해 임시 테이블을 사용한다.
- 하지만 이 쿼리의 실행 계획에는 임시 테이블을 사용한다는 메시지는 표시하지 않는다.
- 만약 위 쿼리에 COUNT(DISTINCT ...)를 하나 더 추가해보자.

```sql
SELECT COUNT(DISTINCT s.salary), COUNT(DISTINCT e.last_name)
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no
AND e.emp_no BETWEEN 100001 AND 100100;
```

- s.salary 칼럼의 값을 저장하는 임시 테이블과 e.last_name 칼럼의 값을 저장하는 또 다른 임시 테이블이 필요하므로 전체적으로 2개의 임시 테이블을 사용한다.
- 임시 테이블을 사용하는 이유는 인덱스를 사용할 수 없기 때문이다.

```sql
SELECT COUNT(DISTINCT emp_no) FROM employees;
SELECT COUNT(DISTINCT emp_no) FROM dept_emp GROUP BY dept_no;
```

- 위와 같이 인덱스된 칼럼에 대해 DISTINCT 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 처리를 수행할 수 있다.

### 6.3.5 임시 테이블(Using temporary)

- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그룹핑할 때는 내부적인 임시 테이블을 사용한다.
- 일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다. 물론 특정 케이스에는 메모리를 거치지 않고 바로 디스크에 임시 테이블이 만들어지기도 한다.
- 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진을 사용하며, 디스크에 저장될 때는 MyISAM 스토리지 엔진을 이용한다.
- 이 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능하다. 내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제 된다.
