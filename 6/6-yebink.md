# 6장. 실행 계획

`EXPLAIN` 키워드를 쿼리 앞에 붙여서 쿼리의 실행 계획을 확인할 수 있다.



## 6-1. 개요

### 쿼리 실행 절차

1.  **SQL 파싱** *by SQL 파서*

   SQL 파서가 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.

2. **최적화 및 실행 계획 수립** *by 옵티마이저*

   SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고, 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.

   - *불필요한 조건의 제거* 및 *복잡한 연산 단순화*
   - 여러 테이블이 조인된 경우, *어떤 순서로 읽을지 결정*
   - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 *사용할 인덱스 결정*
   - 가져온 레코드들을 *임시 테이블*에 넣고 다시 한 번 가공해야 하는지 결정

3. **레코드 읽어오기 및 조인, 정렬**

   두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다. 



<br/>

#### 참고 1) MySQL 서버 구성

![image](https://user-images.githubusercontent.com/19922698/99898121-875a3880-2ce2-11eb-831b-f9a5df2800ec.png)

<br/>



#### 참고 2) 옵티마이저의 종류

- **비용 기반 최적화 (Cost-based Optimizer, CBO) 🙂**  (MySQL 채택 ✅)

  쿼리를 처리하기 위한 여러가지 가능한 방법을 뽑아보고, 각각의 단위 작업의 비용 정보, 통계 정보를 이용해 실행 계획별로 비용을 산출한다. 이 중 최소 비용이 소요되는 방식을 선택한다.

- **규칙 기반 최적화 (Rule-based Optimizer, RBO) :frowning_face:**

  쿼리를 칠 테이블의 레코드 수, 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 처리한다. (비용 정보, 통계 정보 고려 X)

<br/>

MySQL의 통계 정보는 레코드 건수, 인덱스의 유니크한 값의 개수 (그렇게 다양하지는 않다), 동적으로 자동으로 변경된다.

이를 `ALALYZE` 명령을 통해 강제적으로 통계 정보를 갱신할 수도 있다. (인덱스 키값의 선택도를 update)

```sql
SHOW INDEX FROM [테이블명];

ANALYZE TABLE [테이블명];
```

- ANALYZE를 실행하는 동안 MyISAM은 읽기 락, InnoDB는 쓰기 락이 걸리므로 서비스 도중엔 실행하지 않는 게 좋다.
- MyISAM은 정확한 키값 분포도를 위해 인덱스 전체 스캔 (시간 오래 걸림), InnoDB는 인덱스 페이지 중 8개 랜덤 선택. 



<br/>