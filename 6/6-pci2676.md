# 6. 실행계획

## 6.1 개요

### 쿼리 실행 절차

MySQL은 어떻게 쿼리를 실행하는가?

1. SQL를 MySQL 서버가 이해할 수 있도록 쪼갠다(=파싱 트리를 만든다).
2. 파싱 트리를 이용해서 어떤 테이블을 읽고 어떤 인덱스를 이용할지 선택한다.
3. 선택된 테이블 읽기 순서, 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

</br>

### 옵티마이저 종류

- 규칙 기반 최적화 : 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식으로 이제 잘 사용하지 않는다.
- **비용 기반 최적화** : 예측된 통계 정보를 이용해 최소 비용이 소요되는 처리방식을 선택하는 현대의 방식이다.

</br>

### 통계 정보

비용 기반 최적화에 사용되는 정보가 통계 정보이다. 부정확한 통계는 0.1초에 끝날 쿼리를 1시간 짜리 쿼리로 만들어 버릴 수 있다.

레코드 건수가 많지 않으면 통계정보가 부정확한 경우가 생기는데 이를 위해 `ANALYZE` 명령어를 사용해서 강제로 통계정보를 갱신하기도 한다. 레코드 건수가 얼마 되지 않는 개발용 MySQL 서버에서 자주 발생한다.

`ANALYZE` 명령어를 사용하면 InnoDB 기반의 테이블은 읽기와 쓰기 모두 불가능해진다. 따라서 서비스 도중에는 실행하지 않는 것이 좋다.

</br>

## 6.2 실행 계획 분석

`EXPLAIN` 키워드를 `SELECT` 쿼리 문장앞에 적어주면 실행 계획이 출력된다.

실행 계획에서 위쪽에 출력된 결과일수록 쿼리의 바깥부분, 혹은 먼저 접근한 테이블이다.

복잡하거나 무거운 쿼리를 실행한다면 실행 계획의 조회 또한 느려질수 있다. 그리고 `UPDATE`, `DELETE`, `INSERT` 의 경우 실행계획을 확인 할 수 없다. 이 경우 `WHERE` 을 적절히 변경해서 `SELECT` 를 이용해서 조회하도록 하자.

</br>

### select_type 컬럼

#### DEPENDENT

내부 쿼리가 외부의 값을 참조해서 처리될때 `DEPENDENT` 키워드가 나타나는데 외부 값이 내부 쿼리에 영향을 미치므로 **외부 쿼리가 먼저 실행된 후 내부 쿼리가 실행**이 된다. 따라서 이러한 경우 **쿼리가 비효율적인 경우가 많다**.

#### DERIVED

select_type이 `DERIVED` 인 경우 파생 테이블이라고 불린다. 서브 쿼리가 `FROM` 절에 사용된 경우 `DERIVED` 인 실행 계획이 나오는데 이는 실행 결과를 메모리나 디스크에 임시 테이블을 생성(파생)한다는 것이다. MySQL은 `FROM` 절에 사용된 서브쿼리를 최적화 하지 못하는 경우가 많다. **파생 테이블**에는 당연히 **인덱스가 없기 때문에 다른 테이블과 조인할 때 성능이 좋지 않다**.

:arrow_right: ​**`FROM` 절에는 서브 쿼리 작성을 지양하도록 하자. ** 보통의 경우 서브 쿼리는 조인으로 해결할 수 있다.

</br>

### type 컬럼

각 테이블의 레코드를 **어떤 방식으로 읽었는지를 의미**한다. 실행 계획에서 type 컬럼은 반드시 체크해야한다. 다시말하면 테이블의 접근 방식으로 해석하면 된다.

아래는 type 컬럼의 종류로 왼쪽부터 빠른 순으로 정렬하였다.

`system` > `cosnt` > `eq_ref` > `ref` > `fulltext` > `ref_or_null` > `unique_subquery` > `index_subquery` > `range` > `index_merge` > `index` > `ALL`

`ALL` 방식은 인덱스를 사용하지 않는 방식으로 테이블을 풀 스캔한다. 따라서 성능이 가장 안좋다.

`index_merge`를 제외한 모든 접근 방법은 인덱스를 한 개만 사용한다.

#### system

레코드가 1건만 존재하거나 존재하지 않는 테이블을 참조하는 형태이다. 하지만 InnoDB 테이블에는 나타나지 않고 MyISAM 과 MEMORY 테이블에만 나타난다. 쿼리 형태에 따라 `ALL` 혹은 `index` 로 표기될 것이다.

#### const

테이블의 레코드 건수와 무관하고 **PK, UK인 컬럼을 WHERE 절에서 사용**하며 반환 **결과가 반드시 1건**이라면 `const` 가 출력된다.  
일명 유니크 인덱스 스캔

그런데 PK, UK를 **다중 컬럼으로 생성**했다면 해당 컬럼중 **일부만을 이용해서 쿼리를 작성하면 `const` 로 접근 하지 않는다**.  
다중 컬럼을 전부 사용하지 않고 일부만 사용한다면 `ref` 로 표기할 것이다.

#### eq_ref

1. 여러 테이블이 조인되어야 한다.
2. 처음 읽은 테이블의 컬럼을 다음 테이블의 PK, UK의 검색 조건에 사용되어야 한다.
   - UK를 사용할 경우 NOT NULL 이어야 한다.
   - 다중 컬럼으로 구성된 PK, UK 라면 모든 컬럼이 비교 조건에 사용되어야 한다.

위의 조건을 만족하는 경우 두 번째 이후 읽히는 테이블에서 `type` 에 `eq_ref` 가 나타난다.

두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 한다.

#### ref

조인의 순서와 관계없이 사용되고 PK, UK 제약조건도 필요없다.

**인덱스를 동등 조건으로 검색**할 때 `ref` 접근이 사용된다.

</br>

위에서 살펴본 `const`, `eq_ref`, `ref` 의 경우 모두 `WEHERE` 절 에서 비교 연산자가 **동등 비교 연산자여야 한다**는 공통점이 있다.

위 세 가지 방법은 꽤 좋은 접근 방법이므로 튜닝할 때 크게 신경쓰지 않아도 좋다.

</br>

#### fulltext

전문 검색 인덱스는 통계 정보가 관리되지 않는다 (최적화 하기 힘들다). 그런데 전문 검색 조건의 우선순위가 꽤 높다. `const`, `eq_ref`, `ref` 가 아니면 전문 인덱스를 사용하려고 한다.

전문 검색은 `MATCH ... AGAINST ...` 구문을 사용하는데 **전문 인덱스가 없다면 오류가 발생**한다.

#### ref_or_null

`ref` 접근 방식과 같은데, `NULL` 비교가 추가된 형태이다. **실무에서 잘 안보인다고 한다.**

#### unique_subquery

`WHERE` 절에서 `IN` 을 이용한 쿼리를 위한 접근 방식이다.  **서브 쿼리에서 중복되지 않는 유니크한 값만 반환할 때** 이 접근 방법을 사용한다.

#### index_subquery

`IN`  절에 사용되는 서브 쿼리의 중복된 결과 값이 인덱스를 이용해서 제거할 수 있을 때 사용된다.

`unique_subquery` vs `index_subquery` : `IN` 절 내의 중복 제거 작업이 필요한가 아닌가

</br>

#### range

인덱스 레인지 스캔 형태의 접근 방법이다.

즉, 범위로 검색을 하는 경우인데. `<`, `>`, `IS NULL`, `BETWEEN`, `IN`, `LIKE` 등의 연산자에 인덱스를 사용할 때 사용된다.

**우선순위는 낮지만 접근 속도는 빠른 편으로 성능을 어느정도 보장해준다.** 

#### index_merge

2개 이상의 인덱스를 사용하여 검색 결과를 만들고 결과를 병합하는 방식이다.

효율적으로 동작하지 않는다.

1. range 보다 비효율적이다.
2. 최적화가 되지 않을때가 많다.
3. 전문 검색 인덱스에 적용되지 않는다.
4. 집합의 형태로 결과를 반환하는데 중복 제거와 같은 부가 작업이 필요하다.

</br>

#### index

**인덱스 풀 스캔을 의미한다. 필요한 부분만을 읽는 효율적인 방법이 아니다.**

풀 테이블 스캔과 같이 비교하는 레코드 건수는 같지만, 정렬되어 있는 인덱스를 사용하기 때문에 조금 더 낫긴하다.

#### ALL

풀 테이블 스캔, 가장 비효율적인 방법

InnoDB의 경우 한꺼번에 많은 페이지를 읽어들이는 Read Ahead 방식으로 내부적으로 최적화한다.

</br>

**:arrow_right: 쿼리를 튜닝한다는 것이 무조건 인덱스 풀 스캔이나 테이블 풀 스캔을 벗어나는 것은 아니다.**

