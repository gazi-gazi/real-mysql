# 4장. 트랜잭션과 잠금

## 4.1 트랜잭션

### 트랜잭션?

: 데이터 정합성을 보장하기 위한 기능

작업 셋이 100% 적용되거나(COMMIT) 그렇지 않아야 한다.(ROLLBACK)

### 잠금(락)?

: 동시성을 제어하기 위한 기능



❗️ MyISAM, MEMORY DB는 트랜잭션을 지원하지 않는다.

---

### 트랜잭션의 범위는 최소화하는 것이 좋다.

일반적으로 DB 커넥션은 개수가 제한적이라서 각 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션 개수는 줄어들 것이다. 그래서 메일 전송, 또는 FTP 파일 전송같은 작업은 트랜잭션 범위 내에서 제거하는 것이 좋다.





<br/>

## 4.2 MySQL 엔진의 잠금

크게 **스토리지 엔진 레벨**, **MySQL 엔진 레벨(MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분)**로 나눌 수 있다.

❗️ InnoDB에서는 DDL은 테이블 락, DML(SELECT 제외)은 레코드 락이 걸림, SELECT 시에는 락이 안 걸린다.



### 글로벌 락 (MySQL 서버 전체에 락이 걸림)

- `FLUSH TABLES WITH READ LOCK` 명령으로만 획득 가능
- MySQL에서 제공하는 잠금 가운데 가장 범위가 큰 락
- 한 세션에서 이 락을 획득하면 다른 세션은 쿼리(SELECT 제외한 DDL, DML) 대기해야 함. (모든 테이블에 락이 걸림)

<br/>

### 테이블 락 (테이블 하나에 락이 걸림)

- `LOCK TABLES 테이블명 [READ|WRITE]` 명령으로 특정 테이블의 락 획득, `UNLOCK TABLES` 명령으로 락 반납

- MyISAM, MEMORY 테이블에서 DML(SELECT 제외) 시 발생

<br/>

### 유저 락 (사용자가 지정한 문자열에 대해 락이 걸림)

- `GET_LOCK()` 함수를 이용해 임의로 잠금 설정 가능
- 자주 쓰이지는 않음
- 웹 서비스가 여러 클라이언트와 상호 동기화를 해야 하는 경우 유용

<br/>

### 네임 락 (테이블, 뷰 이름에 대해 락이 걸림)

- `RENAME TABLE 테이블명1 TO 테이블명2` 처럼 테이블 이름 변경 시 자동 획득. (묵시적으로만 호출 가능!)
- 원래 이름, 변경될 이름 둘 다에 대해 락 설정



## 4.3 MyISAM과 MEMORY 스토리지 엔진의 잠금

MyISAM, MEMORY는 자체 잠금이 없기 때문에 MySQL 엔진에서 제공하는 테이블 락을 그대로 사용한다.

**읽기 락 획득**

테이블에 쓰기 잠금이 걸려 있지 않으면 바로 읽기 잠금 획득 후 작업 시작

**쓰기 락 획득**

테이블에 아무런 잠금이 걸려 있지 않아야만 쓰기 잠금 획득 가능, 그렇지 않으면 다른 잠금이 해제될 때까지 대기해야 함.

<br/>

## 4.4 InnoDB 스토리지 엔진의 잠금

MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 **레코드 기반**의 잠금 방식을 탑재하고 있다. 그래서 훨씬 뛰어난 동시성 처리를 제공한다.

<br/>

**비관적 잠금 (InnoDB가 채택)**

현재 트랜잭션에서 변경하고자 하는 레코드를 다른 트랜잭션에서도 변경할 수 있다는 비관적인 가정을 먼저 하기 때문에 해당 레코드에 대한 잠금을 먼저 획득하고 작업을 처리하는 방식

**낙관적 잠금**

각 트랜잭션이 같은 레코드를 변경할 가능성을 상당히 희박할 것이라고 가정하고, 변경을 먼저 수행한 후에 마지막에 잠금 충돌이 있었는지 확인해 문제가 있었다면 롤백하는 방식

<br/>

---

### InnoDB의 잠금 종류

#### 레코드 락

- 레코드 자체만을 잠그는 락.
- ❗️ InnoDB는 레코드 자체가 아니라 인덱스의 레코드를 잠근다. (인덱스가 없더라도 자동 생성된 클러스터 인덱스(PK)를 이용해 잠금을 설정한다.)

<br/>

#### 갭 락

- 레코드 그 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격을 잠금
- 레코드와 레코드 사이의 간격에 새로운 레코드가 INSERT되는 것을 제어한다.
- 이 자체로 사용되기보다는 넥스트 키 락의 일부로 사용된다.

<br/>

#### 넥스트 키 락

- 레코드 락 + 갭 락의 형태.
- `innodb_locks_unsafe_for_binlog=0`이 되면 이 잠금이 걸린다.

<br/>

#### 자동 증가 락

- AUTO_INCREMENT 칼럼이 사용된 테이블에서 동시에 여러 레코드가 INSERT되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가한 일렬번호 값을 가져야 한다.
- INSERT, REPLACE같이 새로운 레코드를 저장하는 쿼리에서만 필요하다. (UPDATE, DELETE X)
- 명시적으로 획득 불가능. 
- 아주 짧은 시간동안만 걸렸다가 해제되기 때문에 대부분 문제가 되지 않는다.

<br/>

### 인덱스와 잠금

InnoDB는 레코드를 잠그는 것이 아니라 인덱스를 잠그는 것이다.

그래서,

```
UPDATE employees SET hire_date=NOW() 
WHERE first_name='Georgi' AND last_name='Klassen';
```

이렇게 1개의 레코드에 대해서만 업데이트를 하면 되는 것을, 인덱스가 first_name에만 걸려있기 때문에 first_name이 George인 253개의 레코드 모두에 잠금을 건다.

<br/>

**🤔 만약 테이블에 인덱스가 없다면?**

테이블을 풀스캔하면서 UPDATE 작업을 처리하게 되므로 테이블에 있는 모든 레코드를 잠그게 된다.

<br/>

**레코드 수준의 잠금 확인 및 해제 방법**

`SELECT * FROM information_schema.innodb_locks;`

`SELECT * FROM information_schema.innodb_trx;`

<br/>



## 4.5 MySQL의 격리 수준

|                 | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ          |
| --------------- | ---------- | ------------------- | --------------------- |
| READ UNCOMMITED | 발생       | 발생                | 발생                  |
| READ COMMITTED  | 발생X      | 발생                | 발생                  |
| REPEATABLE READ | 발생X      | 발생X               | 발생 (InnoDB는 발생X) |
| SERIALIZABLE    | 발생X      | 발생X               | 발생X                 |

<br/>

### READ UNCOMMITED

- 다른 사용자가 데이터 변경 후 아직 커밋되지 않은 사항을 읽어버림.

- 데이터 정합성에 문제가 많은 DIRTY READ가 발생한다.

<br/>

### READ COMMITTED

- 오라클 default
- 변경이 일어날 경우, 변경 전 레코드를 언두 영역에 백업해두고 실제 레코드 값은 변경한다.
- 같은 조회 쿼리에 대해 결과가 다르게 나올 수 있는 NON-REPEATABLE READ 문제가 발생
- ❗️ 바이너리 로그가 활성화된 MySQL 서버는 이 격리 수준을 사용할 수 없다.

<br/>

### REPEATABLE READ

- InnoDB default
- 바이너리 로그를 가진 MySQL 장비에서는 최소 이 격리 수준 이상을 사용해야 한다.
- 변경이 일어날 경우, 변경 전 레코드를 언두 영역에 백업해두고 실제 레코드 값은 변경한다.
- 현재 트랜잭션은 현재 트랜잭션의 번호보다 더 작은 (먼저 실행된 트랜잭션) 번호에서 변경된 것만 보게 된다. <- 요게 READ COMMITED와의 차이
- 하지만 SELECT ... FOR UPDATE 문에서는 여전히 PHANTOM READ가 발생할 수 있다.

<br/>

### SERIALIZABLE

- 가장 단순한, 엄격한 격리 수준
- 동시 처리 능력도 다른 트랜잭션 격리 수준보다 떨어진다.
- InnoDB에서 SELECT 시에 아무 잠금도 일어나지 않지만, 이 격리 수준에서는 읽기 잠금을 획득해야 한다.

<br/>



---

#### **READ COMMITTED** vs **REPEATABLE READ**

- 성능 차이 그렇게 크지 않다.
- 1GB, 30GB 크기 테이블에서 REPEATABLE READ가 2% 정도 높은 성능,
- 100GB 크기 테이블에서 READ COMMITED가 7% 정도 높은 성능.